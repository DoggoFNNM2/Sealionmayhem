<!DOCTYPE html>
<html>
<head>
    <title>TERMINATOR_LINK_v2.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.3.1/dist/peerjs.min.js"></script>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js"></script>
    <style>
        body { margin: 0; background: #000; color: #f00; font-family: 'Courier New', monospace; text-align: center; }
        #setup-ui { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; background: rgba(20,0,0,0.9); padding: 20px; border: 2px solid #f00; }
        #canvasOutput { width: 60%; border: 1px solid #f00; margin-top: 20px; filter: brightness(1.5) contrast(2); }
        video { display: none; }
        .hud { position: absolute; top: 20px; left: 20px; pointer-events: none; text-align: left; }
    </style>
</head>
<body>

    <div id="setup-ui">
        <h2>TERMINATOR_OS_LINK</h2>
        <p>Your ID: <b id="my-id">...</b></p>
        <input type="text" id="peer-id" placeholder="Enter PC ID on Quest">
        <button onclick="connectToPeer()">CONNECT (QUEST SIDE)</button>
        <button onclick="startPC()">START AS SENDER (PC SIDE)</button>
    </div>

    <div class="hud">SYSTEM: <span id="status">IDLE</span><br>POINTS: <span id="pt-count">0</span></div>
    <canvas id="canvasOutput"></canvas>
    <video id="videoInput" playsinline autoplay></video>

    <script type="module">
        import { VRButton } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/webxr/VRButton.js';

        // Settings
        const H_OFFSET = 12.0; 
        const RPC = 0.0016;
        let peer, conn, pointIdx = 0;
        const MAX_POINTS = 50000;

        // Three.js Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(VRButton.createButton(renderer));

        const grid = new THREE.GridHelper(400, 80, 0xff0000, 0x330000);
        grid.position.y = -20;
        scene.add(grid);

        const geo = new THREE.BufferGeometry();
        geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(MAX_POINTS * 3), 3));
        const mat = new THREE.PointsMaterial({ color: 0xff0000, size: 0.15 });
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        // PeerJS Setup
        peer = new Peer();
        peer.on('open', id => document.getElementById('my-id').innerText = id);

        // PC SENDER LOGIC
        window.startPC = () => {
            document.getElementById('setup-ui').style.display = 'none';
            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                const video = document.getElementById('videoInput');
                video.srcObject = stream;
                video.play();
                
                peer.on('connection', c => {
                    conn = c;
                    document.getElementById('status').innerText = "LINKED_TO_QUEST";
                    runDetection();
                });
            });
        };

        // QUEST RECEIVER LOGIC
        window.connectToPeer = () => {
            const id = document.getElementById('peer-id').value;
            conn = peer.connect(id);
            document.getElementById('setup-ui').style.display = 'none';
            conn.on('open', () => {
                document.getElementById('status').innerText = "LINKED_TO_PC";
                conn.on('data', data => {
                    updatePoints(data.x, data.y, data.z);
                });
            });
        };

        function updatePoints(x, y, z) {
            const pos = points.geometry.attributes.position.array;
            pos[pointIdx * 3] = x;
            pos[pointIdx * 3 + 1] = y;
            pos[pointIdx * 3 + 2] = z;
            pointIdx = (pointIdx + 1) % MAX_POINTS;
            points.geometry.attributes.position.needsUpdate = true;
            document.getElementById('pt-count').innerText = pointIdx;
        }

        function runDetection() {
            const video = document.getElementById('videoInput');
            const src = new cv.Mat(video.videoHeight, video.videoWidth, cv.CV_8UC4);
            const hsv = new cv.Mat();
            const mask = new cv.Mat();
            const cap = new cv.VideoCapture(video);

            function process() {
                cap.read(src);
                cv.cvtColor(src, hsv, cv.COLOR_RGBA2RGB);
                cv.cvtColor(hsv, hsv, cv.COLOR_RGB2HSV);
                
                let low = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [0, 0, 245, 0]);
                let high = new cv.Mat(hsv.rows, hsv.cols, hsv.type(), [180, 40, 255, 0]);
                cv.inRange(hsv, low, high, mask);

                let m = cv.moments(mask);
                if (m.m00 > 5 && conn) {
                    let cx = m.m10 / m.m00;
                    let cy = m.m01 / m.m00;
                    let offset = cx - (src.cols / 2);
                    let dist = H_OFFSET / Math.tan(Math.abs(offset) * RPC);
                    
                    conn.send({
                        x: (offset * (dist / 300)) / 5,
                        y: ((src.rows/2 - cy) * (dist / 300)) / 5,
                        z: -dist / 5
                    });
                }
                cv.imshow('canvasOutput', mask);
                low.delete(); high.delete();
                requestAnimationFrame(process);
            }
            process();
        }

        renderer.setAnimationLoop(() => renderer.render(scene, camera));
    </script>
</body>
</html>
